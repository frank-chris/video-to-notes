 We present, in Graphed, an API for the web platform that allows live and rich programming tools and environments to be composed together (timestamp: 0.00). Domain-specific live and rich programming tools can support a diversity of programming tasks from data wrangling to visualization authoring (timestamp: 7.00). But real-world programming requires performing multiple tasks in concert (timestamp: 16.00). In Graphed allows live and rich tools to be used together within larger live programming environments (timestamp: 22.00). It also enables two further forms of composition, embedding environments within each other, and embedding environments in the outside world, including conventional code bases (timestamp: 28.00). First, let's see how live and rich tools can be composed together inside live environments within Graphed (timestamp: 40.00). An artist wants to make a website that shows a visitor three random Wikipedia articles (timestamp: 46.00). They can do this with Graphed Garden, a simple web application that hosts in Graphed components (timestamp: 51.00). In the slot on a fresh Graphed Garden page, the artist begins to type slash and then notebook (timestamp: 56.00). They select the notebook from the autocomplete menu, which inserts a notebook component into the slot (timestamp: 61.00). This is a reactive notebook, like observable (timestamp: 66.00). The artist starts by querying the Wikipedia API (timestamp: 69.00). They do this by inserting a request tool into the first cell in the notebook (timestamp: 72.00). Once they paste in a URL and some basic parameters from the Wikipedia documentation, they immediately see the results of their request on the right (timestamp: 77.00). Now they have the information they need, but it's buried in a complex JSON structure (timestamp: 87.00). To get it out, they insert an extractor component into the next cell (timestamp: 92.00). This is a programming by demonstration tool that lets the artist click on patterns of data to extract them into a simpler structure (timestamp: 97.00). Now the artist has exactly the data they want to show, but as a data structure, rather than as formatted HTML (timestamp: 105.00). To format it, they use a formatted component (timestamp: 115.00). Finally, they add a bit of HTML for a heading (timestamp: 127.00). The final output is looking good, so they test it in GraphGarden's view mode, which runs their notebook invisibly, only displaying the final output (timestamp: 136.00). This is a link they can send to anyone. Their project is online and deployed reactively (timestamp: 143.00). The tools the artist used, request, extractor, and formatter, can be embedded in any environment which supports the engrossed API (timestamp: 149.00). Instead of notebook, the artist could have chosen to build their program in notebook canvas, where pains can be freely positioned in 2D (timestamp: 158.00). The same tools are available here. Within GraphGarden users can pick whatever tools and environments best support their work (timestamp: 165.00). Next, let's see how engrossed allows live environments to be embedded inside of other live environments (timestamp: 172.00). This is an image quilt generator built on top of the Art Institute of Chicago's API (timestamp: 177.00). Here's one way to build it, which could use some improvement (timestamp: 182.00). After an array of objects representing images comes back from the API, each object must be turned into HTML combining the image with artist and title annotations (timestamp: 185.00). This is conventionally done with map, as we show here (timestamp: 194.00). Note how live visibility is not available inside of this complex per-item function (timestamp: 198.00). Although we are inside of a notebook, the benefits of the notebook stop when we encounter a nested scope. Here's a better way (timestamp: 202.00). A map component lets the programmer embed a per-item component which is applied to each item of the array (timestamp: 210.00). Here, the per-item component is a second notebook which provides visibility to each step of the process (timestamp: 215.00). This workflow is possible because engrossed component-based API allows recursive embedding of tools and environments (timestamp: 220.00). Finally, let's take a quick look at how engrossed tools can be embedded in the outside world (timestamp: 227.00). Here's a web app under development in a conventional code base (timestamp: 232.00). The programmer called at the source API but hasn't processed the JSON response yet (timestamp: 237.00). They'd like to use engrossed so they call a React integration called use engrossed, providing it with the response data and setting edit to true (timestamp: 242.00). When they reload their app, a sidebar is visible where they can embed engrossed component directly into their code base (timestamp: 250.00). The component works with data coming live from the running app (timestamp: 261.00). Once the programmer gets results they like, they send the data back to the running app (timestamp: 266.00). It works (timestamp: 271.00). For production use, the programmer saves the engrossed program to their code base and sets edit to false (timestamp: 273.00). Now the sidebar is gone and the use of a live tool is hidden (timestamp: 286.00). With the composition engrossed provides, live and rich programming can begin to match the expressivity and broad usefulness of conventional code (timestamp: 292.00).